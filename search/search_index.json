{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MathComponent Tutorial","text":"<p>Welcome to the MathComponent tutorial!</p> <p>This tutorial shows how to develop, test, and deploy a simple topology consisting of two components:</p> <ol> <li> <p><code>MathSender</code>: A component that receives commands and forwards work to    <code>MathReceiver</code>.</p> </li> <li> <p><code>MathReceiver</code>: A component that carries out arithmetic operations and    returns the results to <code>MathSender</code>.</p> </li> </ol> <p>See the diagram below.</p> <p> </p>"},{"location":"#what-is-covered","title":"What is covered","text":"<p>This tutorial will cover the following concepts:</p> <ol> <li> <p>Defining types, ports, and components in F'.</p> </li> <li> <p>Creating a deployment and running the F' GDS (Ground Data System).</p> </li> <li> <p>Writing unit tests.</p> </li> <li> <p>Handling errors, creating events, and adding telemetry channels.</p> </li> </ol>"},{"location":"#prequisites","title":"Prequisites","text":"<p>This tutorial assumes the following:</p> <ol> <li> <p>Basic knowledge of Unix: How to navigate in a shell and execute programs.</p> </li> <li> <p>Basic knowledge of C++.</p> </li> <li> <p>We advise new F' users to try the HelloWorld Tutorial</p> </li> </ol>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ol> <li>Project Setup</li> <li>Defining Types</li> <li>Constructing Ports</li> <li>Creating Components</li> <li>Developing Deployments</li> <li>Writing Unit Tests</li> <li>Adding Telemetry</li> <li>Error handling</li> </ol>"},{"location":"adding-telemetry/","title":"Adding Telemetry","text":""},{"location":"adding-telemetry/#in-this-section","title":"In this Section","text":"<p>In this section of the tutorial, you will add a telemetry channel to report the number of math operations the <code>MathReceiver</code> has performed. </p> <p>Before reading these steps, do your best to look at the existing files in this tutorial and impletement a telemetry channel on your own. </p> <ol> <li>Add a telemetry channel to <code>MathReceiver.fpp</code>: </li> </ol> <p><pre><code># In: MathReceiver.fpp, under the Telemetry section\n@ Number of math operations \n    telemetry NUMBER_OF_OPS: U32 \n</code></pre> Explanation: Here you defined a telemetry channel  which you arbitrarily named <code>NUMBER_OF_OPS</code> which  carries a 32 bit unsigned integer. </p> <ol> <li>Add a member variable to <code>MathReceiver.hpp</code>:</li> </ol> <pre><code>// In: MathReceiver.hpp\n// Under: PRIVATE\nU32 numMathOps; \n</code></pre> <ol> <li>Update the constructor so that it initializes <code>numMathOps</code> to zero:</li> </ol> <pre><code>// In: MathReceiver.cpp \n// Under: Construction, Initialization, and Destruction \nMathReceiver ::\n    MathReceiver(\n        const char *const compName\n    ) : MathReceiverComponentBase(compName),\n        numMathOps(0) \n  {\n\n  }\n</code></pre> <ol> <li>Increment numMathOps: </li> </ol> <pre><code>// In: MathReceiver.cpp \n// Within mathOpIn_handler\nnumMathOps++;  \n</code></pre> <ol> <li> <p>Emit telemtry:  <pre><code>// In: MathReceiver.cpp \n// Within: mathOpIn_handler\n// After: numMathOps++\nthis-&gt;tlmWrite_NUMBER_OF_OPS(numMathOps); \n</code></pre></p> <p>Note: This function will get autocoded by FPP since we defined the telemetry channel.</p> </li> <li> <p>Add the channel to the pre-existing MathReceiver packet in <code>MathDeploymentPackets.xml</code>:</p> </li> </ol> <pre><code>    &lt;!-- In: MathDeploymentPackets.xml --&gt;\n    &lt;packet name=\"MathReceiver\" id=\"22\" level=\"3\"&gt;\n        &lt;channel name = \"mathReceiver.OPERATION\"/&gt;\n        &lt;channel name = \"mathReceiver.FACTOR\"/&gt;\n        &lt;channel name = \"mathReceiver.NUMBER_OF_OPS\"/&gt;  &lt;!-- Add this line --&gt;\n    &lt;/packet&gt;\n</code></pre> <ol> <li>Build and test:</li> </ol> <pre><code># In: MathProject\nfprime-util build -j4 \nfprime-gds \n</code></pre> <p>Send a command and verify that the channel gets value 1.</p> <p>Write some unit tests to prove that this channel is working. </p>"},{"location":"adding-telemetry/#summary","title":"Summary","text":"<p>In this section you defined a telemtry channel and impletemented a new variable, that will be sent through the channel.</p> <p>Next: Error handling 1</p>"},{"location":"constructing-ports/","title":"Constructing Ports","text":""},{"location":"constructing-ports/#background","title":"Background","text":"<p>A port is the endpoint of a connection between two components. A port definition is like a function signature; it defines the type of the data carried on a port.</p>"},{"location":"constructing-ports/#requirements","title":"Requirements","text":"<p>For this tutorial, you will need two port definitions:</p> <ul> <li> <p><code>OpRequest</code> for sending an arithmetic operation request from <code>MathSender</code> to <code>MathReceiver</code>.</p> </li> <li> <p><code>MathResult</code> for sending the result of an arithmetic operation from <code>MathReceiver</code> to <code>MathSender</code>.</p> </li> </ul>"},{"location":"constructing-ports/#in-this-section","title":"In this section","text":"<p>In this section, you will create a <code>Ports</code> directory where you will create two ports in <code>MathPorts.fpp</code>. You will add the ports directory into the project build and built <code>Ports</code>.</p>"},{"location":"constructing-ports/#setup","title":"Setup","text":"<p>Start by making a directory where the ports will be defined. Create a directory called <code>Ports</code> in the <code>MathProject</code> directory:</p> <pre><code># In: MathProject\nmkdir Ports\ncd Ports\n</code></pre> <p>While in \"Ports\", create an empty fpp file called <code>MathPorts.fpp</code>, this is where the ports will be defined:</p> <pre><code># In: Ports\ntouch MathPorts.fpp\n</code></pre>"},{"location":"constructing-ports/#implementing-the-ports","title":"Implementing the Ports","text":"<p>Use your favorite text editor to add the following to <code>MathPorts.fpp</code>:</p> <pre><code># In: MathPorts.fpp\nmodule MathModule {\n  @ Port for requesting an operation on two numbers\n  port OpRequest(\n    val1: F32 @&lt; The first operand\n    op: MathOp @&lt; The operation\n    val2: F32 @&lt; The second operand\n  )\n\n  @ Port for returning the result of a math operation\n  port MathResult(\n    result: F32 @&lt; the result of the operation\n  )\n}\n</code></pre> <p>Notice how we define ports in MathModule, which is where we defined MathOp as well.</p> <p>Here, you have created two ports. The first port, called OpRequest, carries two 32-bit floats (<code>val1</code> and <code>val2</code>) and a math operations <code>op</code>. The second port only carries one 32-bit float (result). The first port is intended to send an operation and operands to the <code>MathReceiver</code>. The second port is designed to send the results of the operation back to <code>MathSender</code>.</p> <p>For more information about port definitions, see The FPP User's Guide.</p>"},{"location":"constructing-ports/#adding-to-the-build","title":"Adding to the Build","text":"<p>Create a <code>CMakeLists.txt</code> file in <code>Ports</code>.</p> <pre><code># In: Ports\ntouch CMakeLists.txt\n</code></pre> <p>Add the following to the <code>CMakeLists.txt</code>.</p> <pre><code># In: Ports/CMakeLists.txt\nset(SOURCE_FILES\n  \"${CMAKE_CURRENT_LIST_DIR}/MathPorts.fpp\"\n)\n\nregister_fprime_module()\n</code></pre> <p>Add the following to <code>project.cmake</code>. Remember that <code>project.cmake</code> is in MathProject, not Ports.</p> <pre><code># In: MathProject/project.cmake\nadd_fprime_subdirectory(\"${CMAKE_CURRENT_LIST_DIR}/Ports/\")\n</code></pre> <p>Ports should build without any issues. Use the following to build:</p> <pre><code># In: Ports\nfprime-util build\n</code></pre> <p>Check in <code>MathProject/build-fprime-automatic-native/MathPorts</code> for port definitions. The names of the auto-generated C++ files end in <code>*PortAc.hpp</code> and <code>*PortAc.cpp</code>. Note however, the auto-generated C++ port files are used by the autocoded component implementations; you won't ever program directly against their interfaces.</p>"},{"location":"constructing-ports/#conclusion","title":"Conclusion","text":"<p>At this point, you have succefully implemented all the ports used for this tutorial and added them to the build.</p> <p>Next: Creating Components Part 1: Creating the MathSender</p>"},{"location":"creating-components-1/","title":"Creating Components Part 1: Creating the MathSender","text":""},{"location":"creating-components-1/#background","title":"Background","text":"<p>Components are the lifeblood of an F' deployment. In this tutorial the components are strickly virtual, however in many deployments components will represent unique pieces of hardware, such as sensors and microcontrollers! </p>"},{"location":"creating-components-1/#in-this-section","title":"In this section","text":"<p>In this section, you will begin creating an active component and write its F Prime Prime (fpp) implementation. You will generate cpp and hpp files using the fpp. Note, that you will implement component behavior in <code>MathSender.cpp</code> in the next section. Most commonly, the steps to create a new component are the following: 1. Construct the FPP model. 2. Add the model to the project. 3. Build the stub implementation. 4. Complete the implementation. 5. Write and run unit tests.</p>"},{"location":"creating-components-1/#component-description","title":"Component Description","text":"<p>The <code>MathSender</code> is an active component which receives parameters, sends parameters, logs events, and sends telemetry. </p> <p>With the component description in mind, use the following command to create the <code>MathSender</code> component:</p>"},{"location":"creating-components-1/#creating-the-mathsender","title":"Creating the MathSender","text":"<p>F\u00b4 projects conveniently come with a <code>Components/</code> folder to create components in. It is not required for components to live there, but this tutorial will make use of it.</p> <p><pre><code># In: MathProject/Components/\nfprime-util new --component \n</code></pre> This command will prompt you for some inputs. Answer the prompts as shown below: </p> <pre><code>[INFO] Cookiecutter source: using builtin\nComponent name [MyComponent]: MathSender \nComponent short description [Example Component for F Prime FSW framework.]: Active component used for sending operations and operands to the MathReceiver.\nComponent namespace [Component]: MathModule\nSelect component kind:\n1 - active\n2 - passive\n3 - queued\nChoose from 1, 2, 3 [1]: 1\nEnable Commands?:\n1 - yes\n2 - no\nChoose from 1, 2 [1]: 1\nEnable Telemetry?:\n1 - yes\n2 - no\nChoose from 1, 2 [1]: 1\nEnable Events?:\n1 - yes\n2 - no\nChoose from 1, 2 [1]: 1\nEnable Parameters?:\n1 - yes\n2 - no\nChoose from 1, 2 [1]: 1\n[INFO] Found CMake file at 'MathProject/project.cmake'\nAdd component Components/MathSender to MathProject/project.cmake at end of file (yes/no)? yes\nGenerate implementation files (yes/no)? yes\n</code></pre> <p>Before doing anything to the files you have just generated, try building:</p> <pre><code>cd MathSender\nfprime-util build\n</code></pre>"},{"location":"creating-components-1/#editing-the-fpp-model","title":"Editing the FPP Model","text":"<p>Now that you have created the component, you can start working on implementing the component behavior. The first part of implementing component behavior is editting the fpp file. The fpp file will specify what goes into the autogenerated cpp and hpp files. Writing the fpp file will not implement component behavior on its own, but it will generate templates for most of what you will write in cpp and hpp files. </p> <p>In <code>Components/MathSender</code>, open <code>MathSender.fpp</code> and entirely replace its contents with the following: </p> <pre><code># In: MathSender.fpp\nmodule MathModule {\n\n  @ Component for sending a math operation\n  active component MathSender {\n\n    # ----------------------------------------------------------------------\n    # General ports\n    # ----------------------------------------------------------------------\n\n    @ Port for sending the operation request\n    output port mathOpOut: OpRequest\n\n    @ Port for receiving the result\n    async input port mathResultIn: MathResult\n\n    # ----------------------------------------------------------------------\n    # Special ports\n    # ----------------------------------------------------------------------\n\n    @ Command receive port\n    command recv port cmdIn\n\n    @ Command registration port\n    command reg port cmdRegOut\n\n    @ Command response port\n    command resp port cmdResponseOut\n\n    @ Event port\n    event port eventOut\n\n    @ Telemetry port\n    telemetry port tlmOut\n\n    @ Text event port\n    text event port textEventOut\n\n    @ Time get port\n    time get port timeGetOut\n\n    # ----------------------------------------------------------------------\n    # Commands\n    # ----------------------------------------------------------------------\n\n    @ Do a math operation\n    async command DO_MATH(\n                           val1: F32 @&lt; The first operand\n                           op: MathOp @&lt; The operation\n                           val2: F32 @&lt; The second operand\n                         )\n\n    # ----------------------------------------------------------------------\n    # Events\n    # ----------------------------------------------------------------------\n\n    @ Math command received\n    event COMMAND_RECV(\n                        val1: F32 @&lt; The first operand\n                        op: MathOp @&lt; The operation\n                        val2: F32 @&lt; The second operand\n                      ) \\\n      severity activity low \\\n      format \"Math command received: {f} {} {f}\"\n\n    @ Received math result\n    event RESULT(\n                  result: F32 @&lt; The math result\n                ) \\\n      severity activity high \\\n      format \"Math result is {f}\"\n\n    # ----------------------------------------------------------------------\n    # Telemetry\n    # ----------------------------------------------------------------------\n\n    @ The first value\n    telemetry VAL1: F32\n\n    @ The operation\n    telemetry OP: MathOp\n\n    @ The second value\n    telemetry VAL2: F32\n\n    @ The result\n    telemetry RESULT: F32\n\n  }\n\n}\n</code></pre>"},{"location":"creating-components-1/#about-this-component","title":"About this Component","text":"<p>The above code defines <code>MathSender</code> component. The component is active, which means it has its own thread.</p> <p>Inside the definition of the <code>MathSender</code> component are several specifiers. We have divided the specifiers into five groups.</p> <ol> <li> <p>General ports: These are user-defined ports for application-specific functions. There are two general ports: an output port <code>mathOpOut</code> of type <code>OpRequest</code> and an input port <code>mathResultIn</code> of type <code>MathResult</code>. Notice that these port specifiers use the ports that you defined. The input port is asynchronous. This means that invoking the port (i.e., sending data on the port) puts a message on a queue. The handler runs later, on the thread of this component.</p> </li> <li> <p>Special ports: These are ports that have a special meaning in F Prime. There are ports for registering commands with the dispatcher, receiving commands, sending command responses, emitting event reports, emitting telemetry, and getting the time.</p> </li> <li> <p>Commands: These are commands sent from the ground or from a sequencer and dispatched to this component. There is one command <code>DO_MATH</code> for doing a math operation. The command is asynchronous. This means that when the command arrives, it goes on a queue and its handler is later run on the thread of this component </p> </li> <li> <p>Events: These are event reports that this component can emit. There are two event reports, one for receiving a command and one for receiving a result.</p> </li> <li> <p>Telemetry: These are channels that define telemetry points that the this component can emit. There are four telemetry channels: three for the arguments to the last command received and one for the last result received.</p> </li> </ol> <p>For more information on defining components, see the FPP User's Guide.</p>"},{"location":"creating-components-1/#generate-the-implementation-files","title":"Generate the Implementation Files","text":"<p>Now you have written the FPP code for the component, but the cpp and hpp files do not yet reflect the changes you have made to the fpp file. To get the cpp and hpp to reflect the specs you have defined in the fpp, you need to use the implement command as shown below:</p> <pre><code># In: MathSender\nfprime-util impl \n</code></pre> <p>Now, In <code>MathSender</code>, you will see two new files, <code>MathSender.cpp-template</code> and <code>MathSender.hpp-template</code>. The template files are the files you just generated using the FPP model. Whenever F' generates code, it creates new file with the <code>-template</code> so as to not burn down any old code. In this case, you did not write anything in the original <code>MathSender.cpp</code> or <code>MathSender.hpp</code>, so you can use a move command to replace the old code with the new code:</p> <pre><code># In: MathSender\nmv MathSender.cpp-template MathSender.cpp\nmv MathSender.hpp-template MathSender.hpp\n</code></pre> <p>Build MathSender to make sure everything worked as expected.</p> <pre><code># In: MathSender \nfprime-util build \n</code></pre>"},{"location":"creating-components-1/#wait-shouldnt-you-add-this-to-the-build","title":"Wait... Shouldn't You Add this to the Build?","text":"<p>If you've been paying attention to the tutorial thus far, you might be getting some warning bells that you have not added your new component to the build. Fear not, when using <code>fprime-util new --component</code> all of the <code>CMakeLists.txt</code> and <code>project.cmake</code> work was done for you! Take a look at both files to verify for yourself. </p>"},{"location":"creating-components-1/#summary","title":"Summary","text":"<p>You are about two thirds of the way through finishing <code>MathSender</code>. In the next section you will implement <code>MathSender</code>'s component  behavior.</p> <p>Next: Creating Components Part 2: Implementing MathSender Behavior</p>"},{"location":"creating-components-2/","title":"Creating Components Part 2: Implementing MathSender Behavior","text":""},{"location":"creating-components-2/#in-this-section","title":"In this section","text":"<p>In this section you will edit <code>MathSender.cpp</code> to implement the desired component behavior. </p> <p>As a reminder, below is the component behavior you are trying to implement in this section of the tutorial. </p>"},{"location":"creating-components-2/#component-description","title":"Component Description","text":"<p>The <code>MathSender</code> is going to be an active component which will receive parameters, send parameters, log events, and send telemetry. </p>"},{"location":"creating-components-2/#editing-the-do-math-command-handler","title":"Editing the Do Math Command Handler","text":"<p>The handler <code>DO_MATH_handler</code> is called when the <code>MathSender</code> component receives a <code>DO_MATH</code> command. This handler overrides the corresponding pure virtual function in the auto-generated base class. Fill in the handler so that it looks like this:</p> <pre><code>// In: MathSender.cpp\nvoid MathSender ::\n  DO_MATH_cmdHandler(\n      const FwOpcodeType opCode,\n      const U32 cmdSeq,\n      F32 val1,\n      MathOp op,\n      F32 val2\n  )\n{\n  this-&gt;tlmWrite_VAL1(val1);\n  this-&gt;tlmWrite_OP(op);\n  this-&gt;tlmWrite_VAL2(val2);\n  this-&gt;log_ACTIVITY_LO_COMMAND_RECV(val1, op, val2);\n  this-&gt;mathOpOut_out(0, val1, op, val2);\n  this-&gt;cmdResponse_out(opCode, cmdSeq, Fw::CmdResponse::OK);\n}\n</code></pre>"},{"location":"creating-components-2/#explanation","title":"Explanation","text":"<p>The first two arguments to the handler function provide the command opcode and the command sequence number (a unique identifier generated by the command dispatcher). The remaining arguments are supplied when the command is sent, for example, from the F Prime ground data system (GDS). The implementation code does the following:</p> <ol> <li> <p>Emit telemetry and events.</p> </li> <li> <p>Invoke the <code>mathOpOut</code> port to request that <code>MathReceiver</code> perform the operation.</p> </li> <li> <p>Send a command response indicating success. The command response goes out on the special port <code>cmdResponseOut</code>.</p> </li> </ol> <p>In F Prime, every execution of a command handler must end by sending a command response. The proper behavior of other framework components (e.g., command dispatcher, command sequencer) depends upon adherence to this rule. </p> <p>Check the build using:</p> <pre><code># In: MathSender\nfprime-util build\n</code></pre>"},{"location":"creating-components-2/#editing-the-result-handler","title":"Editing the Result Handler","text":"<p>The handler <code>mathResultIn_handler</code> is called when the <code>MathReceiver</code> component code returns a result by invoking the <code>mathResultIn</code> port. Again the handler overrides the corresponding pure virtual function in the auto-generated base class. Fill in the handler so that it looks like this:</p> <pre><code>// In: MathSender.cpp\nvoid MathSender ::\n  mathResultIn_handler(\n      const NATIVE_INT_TYPE portNum,\n      F32 result\n  )\n{\n    this-&gt;tlmWrite_RESULT(result);\n    this-&gt;log_ACTIVITY_HI_RESULT(result);\n}\n</code></pre>"},{"location":"creating-components-2/#explanation_1","title":"Explanation","text":"<p>The implementation code emits the result on the <code>RESULT</code> telemetry channel and as a <code>RESULT</code> event report.</p> <p>Check the build using:</p> <pre><code># In: MathSender\nfprime-util build\n</code></pre>"},{"location":"creating-components-2/#summary","title":"Summary","text":"<p>Congratulations, you have completed <code>MathSender</code>! Well... there's always more to be done, such as error handling, adding more telem, creating more events, and generally messing around with what <code>MathSender</code> can do. But for the purposes of getting a deployment working, this component is done! </p> <p>Next: Creating Components Part 3: Starting the MathReceiver</p>"},{"location":"creating-components-3/","title":"Creating Components Part 3: Starting the MathReceiver","text":""},{"location":"creating-components-3/#in-this-section","title":"In this Section","text":"<p>In this section you will begin creating <code>MathReceiver</code> following the same steps as the last section. Note, that the <code>MathReceiver</code> is a little different than the <code>MathSender</code>.</p>"},{"location":"creating-components-3/#component-description","title":"Component Description","text":"<p>The <code>MathReceiver</code> is a queued component which receives parameters, send parameters, logs events, and sends telemetry. With this is mind, use the following command to create the <code>MathReceiver</code> component. </p>"},{"location":"creating-components-3/#creating-the-mathreceiver","title":"Creating the MathReceiver","text":"<p><pre><code># In: Components\nfprime-util new --component \n</code></pre> This command will prompt you for some inputs. You should specify the follow so that the components matches the short description above. Don't forget that this is a QUEUED component:</p> <pre><code>[INFO] Cookiecutter source: using builtin\nComponent name [MyComponent]: MathReceiver \nComponent short description [Example Component for F Prime FSW framework.]: Your description\nComponent namespace [Component]: MathModule\nSelect component kind:\n1 - active\n2 - passive\n3 - queued\nChoose from 1, 2, 3 [1]: 3 \nEnable Commands?:\n1 - yes\n2 - no\nChoose from 1, 2 [1]: 1\nEnable Telemetry?:\n1 - yes\n2 - no\nChoose from 1, 2 [1]: 1\nEnable Events?:\n1 - yes\n2 - no\nChoose from 1, 2 [1]: 1\nEnable Parameters?:\n1 - yes\n2 - no\nChoose from 1, 2 [1]: 1\n[INFO] Found CMake file at 'MathProject/project.cmake'\nAdd component Components/MathSender to MathProject/project.cmake at end of file (yes/no)? yes\nGenerate implementation files (yes/no)? yes\n</code></pre> <p>Before doing anything to the files you have just generated, try building:</p> <pre><code># In: MathReceiver\nfprime-util build\n</code></pre>"},{"location":"creating-components-3/#editing-the-f-prime-prime-model","title":"Editing the F Prime Prime Model","text":"<p>Now that you have created the component, you can implement the component behavior in the fpp model. Use a text editor to entirely replace the existing <code>MathReceiver.fpp</code> with the following: </p> <pre><code># In: MathReceiver.fpp\nmodule MathModule {\n\n  @ Component for receiving and performing a math operation\n  queued component MathReceiver {\n\n    # ----------------------------------------------------------------------\n    # General ports\n    # ----------------------------------------------------------------------\n\n    @ Port for receiving the math operation\n    async input port mathOpIn: OpRequest\n\n    @ Port for returning the math result\n    output port mathResultOut: MathResult\n\n    @ The rate group scheduler input\n    sync input port schedIn: Svc.Sched\n\n    # ----------------------------------------------------------------------\n    # Special ports\n    # ----------------------------------------------------------------------\n\n    @ Command receive\n    command recv port cmdIn\n\n    @ Command registration\n    command reg port cmdRegOut\n\n    @ Command response\n    command resp port cmdResponseOut\n\n    @ Event\n    event port eventOut\n\n    @ Parameter get\n    param get port prmGetOut\n\n    @ Parameter set\n    param set port prmSetOut\n\n    @ Telemetry\n    telemetry port tlmOut\n\n    @ Text event\n    text event port textEventOut\n\n    @ Time get\n    time get port timeGetOut\n\n    # ----------------------------------------------------------------------\n    # Parameters\n    # ----------------------------------------------------------------------\n\n    @ The multiplier in the math operation\n    param FACTOR: F32 default 1.0 id 0 \\\n      set opcode 10 \\\n      save opcode 11\n\n    # ----------------------------------------------------------------------\n    # Events\n    # ----------------------------------------------------------------------\n\n    @ Factor updated\n    event FACTOR_UPDATED(\n                          val: F32 @&lt; The factor value\n                        ) \\\n      severity activity high \\\n      id 0 \\\n      format \"Factor updated to {f}\" \\\n      throttle 3\n\n    @ Math operation performed\n    event OPERATION_PERFORMED(\n                               val: MathOp @&lt; The operation\n                             ) \\\n      severity activity high \\\n      id 1 \\\n      format \"{} operation performed\"\n\n    @ Event throttle cleared\n    event THROTTLE_CLEARED \\\n      severity activity high \\\n      id 2 \\\n      format \"Event throttle cleared\"\n\n    # ----------------------------------------------------------------------\n    # Commands\n    # ----------------------------------------------------------------------\n\n    @ Clear the event throttle\n    async command CLEAR_EVENT_THROTTLE \\\n      opcode 0\n\n    # ----------------------------------------------------------------------\n    # Telemetry\n    # ----------------------------------------------------------------------\n\n    @ The operation\n    telemetry OPERATION: MathOp id 0\n\n    @ Multiplication factor\n    telemetry FACTOR: F32 id 1\n\n  }\n\n}\n</code></pre>"},{"location":"creating-components-3/#explanation","title":"Explanation","text":"<p>This code defines a component <code>MathReceiver</code>. The component is queued, which means it has a queue but no thread. Work occurs when the thread of another component invokes the <code>schedIn</code> port of this component.</p> <p>We have divided the specifiers of this component into six groups:</p> <ol> <li>General ports: There are three ports:</li> <li>an input port <code>mathOpIn</code> for receiving a math operation, <code>mathOpIn</code> is asynchronous. That means invocations of <code>mathOpIn</code> put messages on a queue.</li> <li>an output port <code>mathResultOut</code> for sending a math result, and</li> <li> <p>an input port <code>schedIn</code> for receiving invocations from the scheduler. <code>schedIn</code> is synchronous. That means invocations of <code>schedIn</code> immediately call the handler function to do work.</p> </li> <li> <p>Special ports: As before, there are special ports for commands, events, telemetry, and time. There are also special ports for getting and setting parameters. We will explain the function of these ports below.</p> </li> <li> <p>Parameters: There is one parameter. A parameter is a constant that is configurable by command. In this case there is one parameter <code>FACTOR</code>. It has the default value 1.0 until its value is changed by command. When doing math, the <code>MathReceiver</code> component performs the requested operation and then multiplies by this factor. For example, if the arguments of the <code>mathOpIn</code> port are v1, <code>ADD</code>, and v2, and the factor is f, then the result sent on <code>mathResultOut</code> is (v1 + v2) f.</p> </li> <li> <p>Events: There are three event reports:</p> </li> <li> <p><code>FACTOR_UPDATED</code>: Emitted when the <code>FACTOR</code> parameter       is updated by command.       This event is throttled to a limit of three.       That means that after the event is emitted three times       it will not be emitted any more, until the throttling       is cleared by command (see below).</p> </li> <li> <p><code>OPERATION_PERFORMED</code>: Emitted when this component       performs a math operation.</p> </li> <li> <p><code>THROTTLE_CLEARED</code>: Emitted when the event throttling       is cleared.</p> </li> <li> <p>Commands: There is one command for clearing the event throttle.</p> </li> <li> <p>Telemetry: There two telemetry channels: one for reporting the last operation received and one for reporting the factor parameter.</p> </li> </ol> <p>For the parameters, events, commands, and telemetry, we chose to put in all the opcodes and identifiers explicitly. These can also be left implicit, as in the <code>MathSender</code> component example. For more information, see the FPP User's Guide.</p>"},{"location":"creating-components-3/#generate-the-implementation-files","title":"Generate the Implementation Files","text":"<p>Generate cpp and hpp files based off your <code>MathReceiver</code> by using: </p> <pre><code># In: MathReceiver \nfprime-util impl\n</code></pre> <p>Replace the orginal cpp and hpp files with the ones you just created:</p> <pre><code># In: MathReceiver\nmv MathReceiver.cpp-template MathReceiver.cpp\nmv MathReceiver.hpp-template MathReceiver.hpp\n</code></pre> <p>Test the build:</p> <pre><code># In: MathReceiver\nfprime-util build \n</code></pre>"},{"location":"creating-components-3/#summary","title":"Summary","text":"<p>You are two thirds of the way through finishing <code>MathReceiver</code>. So far, you have created a queued component stub, filled in the fpp  file, and wrote component charactaristics in <code>MathReceiver.fpp</code>. Next, you will write the behavior for <code>MathReceiver</code>.</p> <p>Next: Creating Components Part 4: Implementing MathReceiver Behavior</p>"},{"location":"creating-components-4/","title":"Creating Components Part 4: Implementing MathReceiver Behavior","text":""},{"location":"creating-components-4/#in-this-section","title":"In this Section","text":"<p>In this section you will complete the implementation of the <code>MathReciever</code> by filling in <code>MathReceiver.cpp</code> and <code>MathReceiver.hpp</code>. </p>"},{"location":"creating-components-4/#editing-the-math-op-in-handler","title":"Editing the Math Op In Handler","text":"<p>Fill in the mathOpIn handler: In MathReceiver.cpp, complete the implementation of <code>MathReceiver::mathOpIn_handler()</code> so that it looks like this:</p> <pre><code>// In: MathReceiver.cpp\nvoid MathReceiver ::\n  mathOpIn_handler(\n      const NATIVE_INT_TYPE portNum,\n      F32 val1,\n      const MathOp&amp; op,\n      F32 val2\n  )\n{\n    // Get the initial result\n    F32 res = 0.0;\n    switch (op.e) {\n        case MathOp::ADD:\n            res = val1 + val2;\n            break;\n        case MathOp::SUB:\n            res = val1 - val2;\n            break;\n        case MathOp::MUL:\n            res = val1 * val2;\n            break;\n        case MathOp::DIV:\n            res = val1 / val2;\n            break;\n        default:\n            FW_ASSERT(0, op.e);\n            break;\n    }//end switch \n\n    // Get the factor value\n    Fw::ParamValid valid;\n    F32 factor = paramGet_FACTOR(valid);\n    FW_ASSERT(\n        valid.e == Fw::ParamValid::VALID || valid.e == Fw::ParamValid::DEFAULT,\n        valid.e\n    );\n\n    // Multiply result by factor\n    res *= factor;\n\n    // Emit telemetry and events\n    this-&gt;log_ACTIVITY_HI_OPERATION_PERFORMED(op);\n    this-&gt;tlmWrite_OPERATION(op);\n\n    // Emit result\n    this-&gt;mathResultOut_out(0, res);\n\n}//end mathOpIn_handler \n</code></pre>"},{"location":"creating-components-4/#explanation","title":"Explanation","text":"<p><code>MathOpIn_Handler</code> does the following:</p> <ol> <li> <p>Compute an initial result based on the input values and the requested operation.</p> </li> <li> <p>Get the value of the factor parameter. Check that the value is a valid value from the parameter database or a default parameter value.</p> </li> <li> <p>Multiply the initial result by the factor to generate the final result.</p> </li> <li> <p>Emit telemetry and events.</p> </li> <li> <p>Emit the result.</p> </li> </ol> <p>Note that in step 1, <code>op</code> is an enum (a C++ class type), and <code>op.e</code> is the corresponding numeric value (an integer type). Note also that in the <code>default</code> case we deliberately fail an assertion. This is a standard pattern for exhaustive case checking. We should never hit the assertion. If we do, then a bug has occurred: we missed a case.</p>"},{"location":"creating-components-4/#editing-the-schedule-handler","title":"Editing the Schedule Handler","text":"<p>Fill in the schedIn handler in <code>MathReceiver.cpp</code>, complete the implementation of <code>schedIn_handler</code> so that it looks like this:</p> <pre><code>// In: MathReceiver.cpp\nvoid MathReceiver ::\n  schedIn_handler(\n      const NATIVE_INT_TYPE portNum,\n      NATIVE_UINT_TYPE context\n  )\n{\n    U32 numMsgs = this-&gt;m_queue.getNumMsgs();\n    for (U32 i = 0; i &lt; numMsgs; ++i) {\n        (void) this-&gt;doDispatch();\n    }\n}\n</code></pre>"},{"location":"creating-components-4/#explanation_1","title":"Explanation","text":"<p>This code dispatches all the messages on the queue. Note that for a queued component, we have to do this dispatch explicitly in the schedIn handler. For an active component, the framework auto-generates the dispatch code.</p>"},{"location":"creating-components-4/#editing-the-throttle-command-hanlder","title":"Editing the Throttle Command Hanlder","text":"<p>Fill in the <code>CLEAR_EVENT_THROTTLE</code> command handler: In <code>MathReceiver.cpp</code>, complete the implementation of <code>CLEAR_EVENT_THROTTLE_cmdHandler</code> so that it looks like this:</p> <pre><code>// In: MathReceiver.cpp\nvoid MathReceiver ::\n  CLEAR_EVENT_THROTTLE_cmdHandler(\n      const FwOpcodeType opCode,\n      const U32 cmdSeq\n  )\n{\n    // clear throttle\n    this-&gt;log_ACTIVITY_HI_FACTOR_UPDATED_ThrottleClear();\n    // send event that throttle is cleared\n    this-&gt;log_ACTIVITY_HI_THROTTLE_CLEARED();\n    // reply with completion status\n    this-&gt;cmdResponse_out(opCode, cmdSeq, Fw::CmdResponse::OK);\n}\n</code></pre>"},{"location":"creating-components-4/#explanation_2","title":"Explanation","text":"<p>The call to <code>log_ACTIVITY_HI_FACTOR_UPDATED_ThrottleClear</code> clears the throttling of the <code>FACTOR_UPDATED</code> event. The next two lines send a notification event and send a command response.</p>"},{"location":"creating-components-4/#writing-a-parameter-checker","title":"Writing a Parameter Checker","text":"<p>Add the following function to <code>MathReceiver.cpp</code>. You will need to add the corresponding function header to <code>MathReceiver.hpp</code>. Note: this function is completely new, there is no prexisting stub for this function.</p> <pre><code>// In: MathReceiver.cpp\nvoid MathReceiver ::\n   parameterUpdated(FwPrmIdType id)\n{\n    switch (id) {\n        case PARAMID_FACTOR: {\n            Fw::ParamValid valid;\n            F32 val = this-&gt;paramGet_FACTOR(valid);\n            FW_ASSERT(\n                valid.e == Fw::ParamValid::VALID || valid.e == Fw::ParamValid::DEFAULT,\n                valid.e\n            );\n            this-&gt;log_ACTIVITY_HI_FACTOR_UPDATED(val);\n            break;\n        }\n        default:\n            FW_ASSERT(0, id);\n            break;\n    }\n}\n</code></pre> <pre><code>// In: MathReceiver.hpp\n// As a Private under: Handler implementations for user-defined typed input ports\nvoid parameterUpdated(FwPrmIdType id);\n</code></pre>"},{"location":"creating-components-4/#explanation_3","title":"Explanation","text":"<p>This code implements an optional function that, if present, is called when a parameter is updated by command. The parameter identifier is passed in as the id argument of the function. Here the function does the following:</p> <ol> <li> <p>If the parameter identifier is PARAMID_FACTOR (the parameter identifier corresponding to the FACTOR parameter), then get the parameter value and emit an event report.</p> </li> <li> <p>Otherwise fail an assertion. This code should never run, because there are no other parameters.</p> </li> </ol>"},{"location":"creating-components-4/#test-the-build","title":"Test the build","text":"<pre><code># In: MathReceiver\nfprime-util build \n</code></pre>"},{"location":"creating-components-4/#summary","title":"Summary","text":"<p>Congratulations, you have finished <code>MathReceiver</code>!</p> <p>Next: Developing Deployments</p>"},{"location":"defining-types/","title":"Defining Types","text":""},{"location":"defining-types/#background","title":"Background","text":"<p>In F Prime, a type definition defines a kind of data that you can pass between components or use in commands and telemetry.</p> <p>For this tutorial, you need one type definition. The type will define an enumeration called <code>MathOp</code>, which represents a mathematical operation.</p>"},{"location":"defining-types/#in-this-section","title":"In this section","text":"<p>In this section, you will create a <code>Types</code> directory and add it to the project build. You will create an enumeration to represent several Mathmatic operations.</p>"},{"location":"defining-types/#setup","title":"Setup","text":"<p>To start, create a directory where your type(s) will live:</p> <pre><code># In: MathProject \nmkdir Types \ncd Types\n</code></pre> <p>The user defines types in an fpp (F prime prime) file. Use the the command below to create an empty fpp file to define the <code>MathOp</code> type:</p> <p><pre><code># In: Types\ntouch MathTypes.fpp\n</code></pre> Here you have created an empty fpp file named MathTypes in the Types directory.</p>"},{"location":"defining-types/#implementing-the-types","title":"Implementing the Types","text":"<p>Use your favorite text editor, visual studios, nano, vim, etc..., and add the following to <code>MathTypes.fpp</code>.</p> <pre><code># In: MathTypes.fpp\nmodule MathModule { \n\n    @ Math operations\n    enum MathOp {\n        ADD @&lt; Addition\n        SUB @&lt; Subtraction\n        MUL @&lt; Multiplication\n        DIV @&lt; Division\n  }\n}\n</code></pre> <p>Important note: think of modules similar to a cpp namespace. Whenever you want to make use of the enumeration, <code>MathOp</code>, you will need to use the MathModule module. </p> <p>Above you have created an enumation of the four math types that are used in this tutorial.</p>"},{"location":"defining-types/#adding-to-the-build","title":"Adding to the Build","text":"<p>To specify how <code>MathTypes.fpp</code> should build with the project, you need to make two modifications to the MathProject:</p> <ol> <li>Create and edit <code>CMakeLists.txt</code> in <code>Types</code> to include <code>MathTypes.fpp</code> into the build.</li> </ol> <p>To create CMakeLists.txt use:</p> <pre><code># In: Types\ntouch CMakeLists.txt \n</code></pre> <p>Note: capitalization and spelling is important when creating files!</p> <p>Use a text editor to replace whatever is in CMakeLists.txt, most likely nothing, with the following.</p> <pre><code>set(SOURCE_FILES\n  \"${CMAKE_CURRENT_LIST_DIR}/MathTypes.fpp\"\n)\n\nregister_fprime_module()\n</code></pre> <ol> <li>Add the <code>Types</code> directory to the overall project build by adding to <code>project.cmake</code>.  </li> </ol> <p>Edit <code>project.cmake</code>, located in the <code>MathProject</code> directory, and  add the following line at the end of the file:</p> <pre><code># In: MathProject/project.cmake\nadd_fprime_subdirectory(\"${CMAKE_CURRENT_LIST_DIR}/Types/\")\n</code></pre> <p>The <code>Types</code> directory should now build without any issues. Test the build with the following commmand before moving forward.</p> <pre><code># In: Types \nfprime-util build \n</code></pre> <p>Note: if you have not generated a build cache already, you may need to run <code>fprime-util generate</code> before you can build.</p> <p>The output should indicate that the model built without any errors. If not, try to identify and correct what is wrong, either by deciphering the error output, or by going over the steps again. If you get stuck, you can look at the reference implementation.</p> <p>The advanced user may want to go inspect the generated code. Go to the directory <code>MathProject/build-fprime-automatic-native/MathTypes</code>. The directory <code>build-fprime-automatic-native</code> is where all the generated code lives for the \"automatic native\" build of the project. Within that directory is a directory tree that mirrors the project structure. In particular, <code>build-fprime-automatic-native/MathTypes</code> contains the generated code for <code>MathTypes</code>. The files MathOpEnumAc.hpp and MathOpEnumAc.cpp are the auto-generated C++ files corresponding to the MathOp enum. You may wish to study the file MathOpEnumAc.hpp. This file gives the interface to the C++ class MathModule::MathOp. All enum types have a similar auto-generated class interface.</p>"},{"location":"defining-types/#summary","title":"Summary","text":"<p>At this point you have successfully created the <code>MathOp</code> type  and added it to the project build. You can add more types here  later if you feel so inclined. </p> <p>Next: Constructing Ports</p>"},{"location":"developing-deployments/","title":"Developing Deployments","text":""},{"location":"developing-deployments/#background","title":"Background","text":"<p>The deployment is the portion of F' that will actually run on the spacecraft. Think of the deployment like an executable. </p>"},{"location":"developing-deployments/#in-this-section","title":"In this Section","text":"<p>In this section, you will create a deployment and integrate the deployment with the other work you have completed. At the end of this section, you will run the F' ground data system and test your components by actually running them! </p>"},{"location":"developing-deployments/#create-a-deployment","title":"Create a Deployment","text":"<p>Use the following command to create the deployment: </p> <pre><code># In: MathProject \nfprime-util new --deployment\n</code></pre> <p>When creating the deplyoment you will be asked two questions, answer them as follows: </p> <pre><code>[INFO] Cookiecutter: using builtin template for new deployment\nDeployment [MyDeployment]: MathDeployment\n[INFO] Found CMake file at 'fprime-tutorial-math-component/project.cmake'\nAdd component Deployment to fprime-tutorial-math-component/project.cmake at end of file (yes/no)? yes\n</code></pre> <p>Test the build to make sure everything is okay:</p> <pre><code># In MathProject/MathDeployment\nfprime-util build\n</code></pre>"},{"location":"developing-deployments/#add-component-instances-to-the-deployment","title":"Add Component Instances to the Deployment","text":"<p>Create an instance for <code>MathSender</code> in <code>instances.fpp</code>. </p> <pre><code># In: MathDeployment/Top/instances.fpp \n# Under: Active component instances \ninstance mathSender: MathModule.MathSender base id 0xE00 \\\n  queue size Default.QUEUE_SIZE \\\n  stack size Default.STACK_SIZE \\\n  priority 100\n\n# Under: Queued component instances \ninstance mathReceiver: MathModule.MathReceiver base id 0x2700 \\\n  queue size Default.QUEUE_SIZE\n</code></pre>"},{"location":"developing-deployments/#explanation","title":"Explanation","text":"<p>This code defines an instance <code>mathSender</code> of component <code>MathSender</code>. It has base identifier 0xE00. FPP adds the base identifier to each the relative identifier defined in the component to compute the corresponding identifier for the instance. For example, component MathSender has a telemetry channel MathOp with identifier 1, so instance mathSender has a command MathOp with identifier 0xE01</p> <p>The <code>mathReceiver</code> was defined with base identifier 0x2700 and the default queue size.</p>"},{"location":"developing-deployments/#update-the-topology","title":"Update the Topology","text":"<p>Add the instances you created to <code>topology.fpp</code>. </p> <pre><code># In: MathDeployment/Top/topology.fpp \n# Under: Instances used in the topology\ninstance mathSender\ninstance mathReceiver \n</code></pre> <p>This step highlights the importants of capitalization. The easiest way to differentiate between the component definition and instance is the capitalization.</p>"},{"location":"developing-deployments/#explanation_1","title":"Explanation","text":"<p>These lines add the mathSender and mathReceiver instances to the topology.</p>"},{"location":"developing-deployments/#add-packets","title":"Add Packets","text":"<p>Add packets for MathSender and MathReceiver in MathDeploymentPackets.xml</p> <pre><code>&lt;!-- In: Top/MathDeploymentPackets.xml --&gt;\n&lt;!-- Above: Ignored packets --&gt;\n&lt;packet name=\"MathSender\" id=\"21\" level=\"3\"&gt;\n    &lt;channel name = \"mathSender.VAL1\"/&gt;\n    &lt;channel name = \"mathSender.OP\"/&gt;\n    &lt;channel name = \"mathSender.VAL2\"/&gt;\n    &lt;channel name = \"mathSender.RESULT\"/&gt;\n&lt;/packet&gt;\n&lt;packet name=\"MathReceiver\" id=\"22\" level=\"3\"&gt;\n    &lt;channel name = \"mathReceiver.OPERATION\"/&gt;\n    &lt;channel name = \"mathReceiver.FACTOR\"/&gt;\n&lt;/packet&gt;\n</code></pre>"},{"location":"developing-deployments/#explanation_2","title":"Explanation","text":"<p>These lines describe the packet definitions for the <code>mathSender</code> and <code>mathReceiver</code> telemetry channels.</p>"},{"location":"developing-deployments/#check-the-build","title":"Check the Build","text":"<p>Just to be safe, check the build after this step.</p> <pre><code># In: MathProject/MathDeployment\nfprime-util build\n</code></pre>"},{"location":"developing-deployments/#check-for-unconnected-ports","title":"Check for Unconnected Ports","text":"<p>Check to make sure all of the ports have been connected: </p> <pre><code># In: MathDeployment/Top\nfprime-util fpp-check -u unconnected.txt\ncat unconnected.txt \n</code></pre> <p>At this point in time, several <code>mathSender</code> and <code>mathReceiver</code> ports (such as <code>mathOpIn</code> or <code>schedIn</code>) are still unconnected. Hence, they should appear on this list. </p> <p>Go into <code>topology.fpp</code>, connect <code>mathReceiver.schedIn</code> to rate group one using the code below:  </p> <pre><code># In: Top/topology.fpp \n# Under: connections RateGroups for rateGroup1\nrateGroup1.RateGroupMemberOut[3] -&gt; mathReceiver.schedIn\n</code></pre> <p>Note: <code>[3]</code> is the next available index in rate group one.</p>"},{"location":"developing-deployments/#explanation_3","title":"Explanation","text":"<p>This line adds the connection that drives the <code>schedIn</code> port of the <code>mathReceiver</code> component instance.</p> <p>Verify that you succesfully took a port off the list of unconnected ports. </p> <p>Add the connections between the mathSender and mathReceiver</p> <pre><code># In: Top/topology.fpp \n# Under: connections MathDeplyoment \nmathSender.mathOpOut -&gt; mathReceiver.mathOpIn\nmathReceiver.mathResultOut -&gt; mathSender.mathResultIn\n</code></pre>"},{"location":"developing-deployments/#test-and-run","title":"Test and Run","text":"<p>Re-run the check for unconnected ports: Notice that no mathSender or mathReceiver ports are unconnected. </p> <p>Go into MathDeploymentTopology.cpp and uncomment <code>loadParameters();</code>. This function is commented by default because it does not exist when the model has no parameters. Since we defined a parameter in <code>MathReceiver</code>, we shall call the function.</p> <pre><code>// In: MathDeploymentTopology.cpp\n// Under: namespace MathDeployment{\nloadParameters();\n</code></pre> <p>Now it is time to build the entire project and run it! Navigate back to <code>MathDeployment</code> and build:</p> <pre><code># In: MathProject/MathDeployment\nfprime-util build \n</code></pre> <p>Run the MathComponent deployment through the GDS:</p> <pre><code># In: MathProject/MathDeployment\nfprime-gds \n</code></pre> <p>If you encounter an error on this step, try running <code>fprime-gds</code> in the <code>MathProject</code>. </p>"},{"location":"developing-deployments/#send-some-commands","title":"Send Some Commands","text":"<p>Under Commanding there is a dropdown menu called \"mnemonic\". Click Mnemonic and find mathSender.DO_MATH. When you select DO_MATH, three new option should appear. In put 7 into val1, put 6 into val2, and put MUL into op. Press send command. Navivate to Events (top left) and find the results of your command. You should see The Ultimate Answer to Life, the Universe, and Everything: 42.</p> <p>For a more detailed guide to the F\u00b4 GDS, see the GDS Introduction Guide.</p>"},{"location":"developing-deployments/#summary","title":"Summary","text":"<p>In this section of the tutorial, you created a deployment. While at it, you filled out the projects instance and topology. These steps are what turn a bunch hard worked code into flight-software. Further more, you ran the software! </p>"},{"location":"developing-deployments/#congratulations","title":"Congratulations","text":"<p>You have completed your F' deployment!!! If you wish to stop here, you may! You can also rest assured knowing that the work you have done is referencable. In otherwords, you've written code in the same way that you will write code for actual spacecrafts. Except... actual spacecrafts will make extensive use of unit tests and error handling. Keep going in this tutorial to learn more about unit testing, error handling, and just to practice using F'.</p> <p>Next: Writing Unit Tests Part 1: Creating the Implementation Stub</p>"},{"location":"error-handling-1/","title":"Error Handling 1: Critical Thinking","text":""},{"location":"error-handling-1/#background","title":"Background","text":"<p>On a flight mission, even a short timeout, let alone a system crash, can be mission critical. It is imparitive that programmer account for as many possible error or faults as possible so avoidable errors are prevented. </p> <p>Think about what will happen if the floating-point math operation performed by <code>MathReceiver</code> causes an error. For example, suppose that <code>mathOpIn</code> is invoked with <code>op = DIV</code> and <code>val2 = 0.0</code>. What will happen? As currently designed and implemented, the <code>MathReceiver</code> component will perform the requested operation. On some systems the result will be <code>INF</code> (floating-point infinity). In this case, the result will be sent back to <code>MathSender</code> and reported in the usual way. On other systems, the hardware could issue a floating-point exception.</p> <p>Suppose you wanted to handle the case of division by zero explicitly. How would you change the design? Here are some questions to think about:</p> <ol> <li> <p>How would you check for division by zero? Note that <code>val2 = 0.0</code> is not the only case in which a division by zero error can occur. It can also occur for very small values of <code>val2</code>.</p> </li> <li> <p>Should the error be caught in <code>MathSender</code> or <code>MathReceiver</code>?</p> </li> <li> <p>Suppose the design says that <code>MathSender</code> catches the error, and so never sends requests to <code>MathReceiver</code> to divide by zero. What if anything should <code>MathReceiver</code> do if it receives a divide by zero request? Carry out the operation normally? Emit a warning? Fail a FSW assertion?</p> </li> <li> <p>If the error is caught by <code>MathReceiver</code>, does the interface between the components have to change? If so, how? What should <code>MathSender</code> do if <code>MathReceiver</code> reports an error instead of a valid result?</p> </li> </ol> <p>Try to revise the MathSender and MathReceiver components to implement your ideas. Challenge yourself to add unit tests covering the new behavior.</p> <p>The next section gives one idea of how to do some error handling for the divide by zero case. Before looking at it, try to solve the problem on your own and compare against the method shown in this tutorial. </p> <p>Next: Error Handling 2</p>"},{"location":"error-handling-2/","title":"Error Handling 2: One Solution","text":""},{"location":"error-handling-2/#example-solution","title":"Example Solution","text":"<p>Below is a basic and incomplete solution to the divide by zero problem presented in the previous section.</p> <p>The solution works as follows: Use an if statement to catch the case that <code>val2</code> (the denominator) is zero. In the case that <code>val2</code> is zero, do nothing with the opperandsand report the error through an event.</p> <p>Use an if statement in <code>MathReceiver.cpp</code> to catchwhen the denominator is zero:</p> <pre><code>// In: MathReceiver.cpp\nF32 res = 0.0;\nswitch (op.e) {\n        case MathOp::ADD:\n            res = val1 + val2;\n            break;\n        case MathOp::SUB:\n            res = val1 - val2;\n            break;\n        case MathOp::MUL:\n            res = val1 * val2;\n            break;\n        case MathOp::DIV:\n            if ( val2 == 0 ){\n\n              break;\n            }\n            res = val1 / val2;\n            break;\n        default:\n            FW_ASSERT(0, op.e);\n            break;\n    }\n</code></pre> <p>Technically speaking, this solution will prevent the error, but it would be good to output some error message before throwing away the opperands and returning the default <code>res</code>.</p> <p>Create an event to notify that a divide by zero command  was received by the <code>MathReceiver</code>:</p> <pre><code># In: MathRecevier.fpp\n@ Commanded to divide by zero\nevent DIVIDE_BY_ZERO   \\\n    severity activity high \\\n    id 3 \\\n    format \"ERROR: Received zero as denominator. Opperands dropped.\"\n</code></pre> <p>Write your own error message between the quotes after <code>format</code>!</p> <p>Add your even into the case where <code>MathOp::DIV</code> and <code>val2</code> is 0:</p> <pre><code>case MathOp::DIV:\n    //step 2\n    if ( val2 == 0 ){\n        this-&gt;log_ACTIVITY_HI_DIVIDE_BY_ZERO();\n        break;\n    }\n</code></pre>"},{"location":"error-handling-2/#summary","title":"Summary","text":"<p>You just created a way to not only handle the case where  <code>MathReceiver</code> is asked to divide by 0, you also created  an event to report that an error has occured. As a challenge,  try to handle more of the cases and problems discussed in Error handling 1.</p>"},{"location":"error-handling-2/#congratulations","title":"Congratulations!!!","text":"<p>You have finished the MathComponent Tutorial. You have now experienced a significant part of F' and are ready to start building your own deployments.</p>"},{"location":"project-setup/","title":"Project Setup","text":""},{"location":"project-setup/#bootstrapping-f","title":"Bootstrapping F\u00b4","text":"<p>Note: if you have followed the HelloWorld tutorial previously, this should feel very familiar...</p> <p>An F\u00b4 project ties to a specific version of tools to work with F\u00b4. In order to create this project and install the correct version of tools, you should perform a bootstrap of F\u00b4.</p> <p>To do this you should follow the following steps from the F\u00b4\u00a0installation guide:</p> <ol> <li>Ensure you meet the F\u00b4\u00a0System Requirements</li> <li>Bootstrap your F\u00b4 project with the name <code>MathProject</code></li> </ol> <p>Bootstrapping your F\u00b4 project created a folder called <code>MathProject</code> (or any name you chose) containing the standard F\u00b4 project structure as well as the virtual environment up containing the tools to work with F\u00b4.</p>"},{"location":"project-setup/#building-the-new-f-project","title":"Building the New F\u00b4 Project","text":"<p>The next step is to set up and build the newly created project. This will serve as a build environment for any newly created components, and will build the F\u00b4 framework supplied components.</p> <pre><code>cd MathProject\nfprime-util generate\nfprime-util build -j4\n</code></pre> <p><code>fprime-util generate</code> sets up the build environment for a project/deployment. It only needs to be done once. At the end of this tutorial, a new deployment will be created and <code>fprime-util generate</code> will also be used then.</p>"},{"location":"project-setup/#summary","title":"Summary","text":"<p>A new project has been created with the name <code>MathProject</code> and has been placed in a new folder called in <code>MathProject</code> in the current directory. It includes the initial build system setup, and F\u00b4 version. It is still empty in that the user will still need to create components and deployments.</p> <p>For the remainder of this Getting Started tutorial we should use the tools installed for our project and issue commands within this new project's folder. Change into the project directory and load the newly install tools with:</p> <pre><code>cd MathProject\n. venv/bin/activate\n</code></pre> <p>Next: Defining Types</p>"},{"location":"writing-unit-tests-1/","title":"Writing Unit Tests Part 1: Creating the Implementation Stub","text":""},{"location":"writing-unit-tests-1/#background","title":"Background","text":"<p>Unit tests are an important part of FSW development. At the component level, unit tests typically invoke input ports, send commands, and check for expected values on output ports (including telemetry and event ports).</p>"},{"location":"writing-unit-tests-1/#in-this-section","title":"In this Section","text":"<p>In this section of the tutorial, you will create a stub implementation of a unit test that will test <code>MathSender</code>. </p> <p>First, let's create our Unit Test build cache:</p> <pre><code># In MathProject\nfprime-util generate --ut \n</code></pre> <p>In Components/MathSender, create a directory called test/ut</p> <pre><code># In: MathSender\nmkdir -p test/ut\n</code></pre> <p>Add the unit test to the build. Absolutely make sure that this is BELOW the existing stuff in the CMakeLists.txt:</p> <pre><code># In: MathSender/CMakeLists.txt\n# Below: register_fprime_module()\n\nset(UT_SOURCE_FILES\n  \"${CMAKE_CURRENT_LIST_DIR}/MathSender.fpp\"\n)\nset(UT_AUTO_HELPERS ON)\nregister_fprime_ut()\n</code></pre>"},{"location":"writing-unit-tests-1/#generate-the-unit-test-stub","title":"Generate the Unit Test Stub","text":"<p>Generate a stub implementation of the unit tests. This stub contains all the boilerplate necessary to write and run unit tests against the <code>MathSender</code> component:</p> <pre><code># In: MathSender\nfprime-util impl --ut\n</code></pre> <p>You haved just generate three new files <code>MathSenderTester.cpp MathSenderTester.hpp MathSenderTestMain.cpp</code>. Move these files to the <code>test/ut</code> in MathSender using:</p> <pre><code># In: MathSender\nmv MathSenderTester.* MathSenderTestMain.cpp test/ut\n</code></pre>"},{"location":"writing-unit-tests-1/#add-the-tests-to-the-build","title":"Add the Tests to the Build","text":"<p>Add <code>MathSenderTester.cpp</code> and <code>MathSenderTestMain.cpp</code> to the build. Do so by editing the CMakeLists.txt to add the 2 new source files. The UT section should now look like the following:</p> <pre><code># In: MathSender/CMakeLists.txt \nset(UT_SOURCE_FILES\n  \"${CMAKE_CURRENT_LIST_DIR}/MathSender.fpp\"\n  \"${CMAKE_CURRENT_LIST_DIR}/test/ut/MathSenderTester.cpp\"\n  \"${CMAKE_CURRENT_LIST_DIR}/test/ut/MathSenderTestMain.cpp\"\n)\nset(UT_AUTO_HELPERS ON)\nregister_fprime_ut()\n</code></pre> <p>Note: most of this is from a few steps ago, you will only be adding two lines in this step. </p> <p>Build the unit test in MathSender:</p> <pre><code># In: MathSender\nfprime-util build --ut \n</code></pre> <p>Don't forget to add <code>--ut</code> or else you are just going to build the component again. </p>"},{"location":"writing-unit-tests-1/#optional-inspect-the-generated-code","title":"(Optional) Inspect the generated code","text":"<p>The unit test build generates some code to support unit testing. The code is located at <code>MathSender/build-fprime-automatic-native-ut/Components/MathSender</code>. This directory contains two auto-generated classes:</p> <ol> <li> <p><code>MathSenderGTestBase</code>: This is the direct base class of <code>Tester</code>. It provides a test interface implemented with Google Test macros.</p> </li> <li> <p><code>MathSenderTesterBase</code>: This is the direct base class of <code>MathSenderGTestBase</code>. It provides basic features such as histories of port invocations. It is not specific to Google Test, so you can use this class without Google Test if desired.</p> </li> </ol> <p>You can look at the header files for these generated classes to see what operations they provide. In the next sections we will provide some example uses of these operations.</p>"},{"location":"writing-unit-tests-1/#summary","title":"Summary","text":"<p>In this section you created the stub implementation of a unit test. In the next section you will finish the unit test and run it. </p> <p>Next: Writing Unit Tests Part 2: Completing the Stub &amp; Running the Test</p>"},{"location":"writing-unit-tests-2/","title":"Writing Unit Tests Part 2: Completing the Stub &amp; Running the Test","text":""},{"location":"writing-unit-tests-2/#in-this-section","title":"In this Section","text":"<p>In this section of the tutorial, you will fill in the stub implementation you created in the last section and run the unit test. </p>"},{"location":"writing-unit-tests-2/#create-a-helper-function","title":"Create a Helper Function","text":"<p>Write a generic helper function so you can reuse code while writing unit tests. Start by writing a function signature in <code>MathSenderTester.hpp</code> in <code>MathSender/test/ut</code>:</p> <pre><code>// In: MathSenderTester.hpp\nvoid testDoMath(MathOp op); \n</code></pre> <p>Fill out the corrosponding function body in <code>MathSenderTester.cpp</code>:</p> <pre><code>// In: MathSenderTester.cpp\n\nvoid MathSenderTester ::\n  testDoMath(MathOp op)\n  {\n    // Pick values\n    const F32 val1 = 2.0;\n    const F32 val2 = 3.0;\n    // Send the command\n    // pick a command sequence number\n    const U32 cmdSeq = 10;\n    // send DO_MATH command\n    this-&gt;sendCmd_DO_MATH(0, cmdSeq, val1, op, val2);\n    // retrieve the message from the message queue and dispatch the command to the handler\n    this-&gt;component.doDispatch();\n    // Verify command receipt and response\n    // verify command response was sent\n    ASSERT_CMD_RESPONSE_SIZE(1);\n    // verify the command response was correct as expected\n    ASSERT_CMD_RESPONSE(0, MathSenderComponentBase::OPCODE_DO_MATH, cmdSeq, Fw::CmdResponse::OK);\n    // Verify operation request on mathOpOut\n    // verify that one output port was invoked overall\n    ASSERT_FROM_PORT_HISTORY_SIZE(1);\n    // verify that the math operation port was invoked once\n    ASSERT_from_mathOpOut_SIZE(1);\n    // verify the arguments of the operation port\n    ASSERT_from_mathOpOut(0, val1, op, val2);\n    // Verify telemetry\n    // verify that 3 channels were written\n    ASSERT_TLM_SIZE(3);\n    // verify that the desired telemetry values were sent once\n    ASSERT_TLM_VAL1_SIZE(1);\n    ASSERT_TLM_VAL2_SIZE(1);\n    ASSERT_TLM_OP_SIZE(1);\n    // verify that the correct telemetry values were sent\n    ASSERT_TLM_VAL1(0, val1);\n    ASSERT_TLM_VAL2(0, val2);\n    ASSERT_TLM_OP(0, op);\n    // Verify event reports\n    // verify that one event was sent\n    ASSERT_EVENTS_SIZE(1);\n    // verify the expected event was sent once\n    ASSERT_EVENTS_COMMAND_RECV_SIZE(1);\n    // verify the correct event arguments were sent\n    ASSERT_EVENTS_COMMAND_RECV(0, val1, op, val2);\n  }\n  ```\n\n## Explanation\nThis function is parameterized over different operations.\nIt is divided into five sections: sending the command, checking the command response, checking the output on `mathOpOut`, checking telemetry, and checking events.\nThe comments explain what is happening in each section. For further information about the F Prime unit test interface, see the F Prime User's Guide.\n\nNotice that after sending the command to the component, we call the function `doDispatch` on the component. We do this in order to simulate the behavior of the active component in a unit test environment.\nIn a flight configuration, the component has its own thread, and the thread blocks on the `doDispatch` call until another thread puts a message on the queue.\nIn a unit test context, there is only one thread, so the pattern is to place work on the queue and then call `doDispatch` on the same thread.\n\nThere are a couple of pitfalls to watch out for with this pattern:\n\n1. If you put work on the queue and forget to call `doDispatch`, the work won't get dispatched.\nLikely this will cause a unit test failure.\n\n2. If you call `doDispatch` without putting work on the queue, the unit test will block until you kill the process (e.g., with control-C).\n\n## Write a Function to Test ADD\n\nYou will now create a function to test the `ADD` command. Add a function signature to MathSenderTester.hpp:\n\n```cpp\n// In: MathSenderTester.hpp\nvoid testAddCommand(); \n</code></pre> <p>Write the corrosponding tester function using the helper funtion you just wrote:</p> <pre><code>// In: MathSenderTester.cpp \nvoid MathSenderTester ::\n    testAddCommand()\n  {\n      this-&gt;testDoMath(MathOp::ADD);\n  }\n</code></pre> <p>Write a Google test macro in MathSenderTestMain.cpp and make sure the test macro goes before main:</p> <pre><code>// In: MathSenderTestMain.cpp\nTEST(Nominal, AddCommand) {\n    MathModule::MathSenderTester tester;\n    tester.testAddCommand();\n}\n</code></pre>"},{"location":"writing-unit-tests-2/#explanation","title":"Explanation","text":"<p>The <code>TEST</code> macro is an instruction to Google Test to run a test. Without this step, your tests will never run. <code>Nominal</code> is the name of a test suite. We put this test in the <code>Nominal</code> suite because it addresses nominal (expected) behavior. <code>AddCommand</code> is the name of the test.  Inside the body of the macro, the first line declares a new object <code>tester</code> of type <code>MathSenderTester</code>. We typically declare a new object for each unit test, so that each test starts in a fresh state. The second line invokes the function <code>testAddCommand</code> that we wrote in the previous section.</p>"},{"location":"writing-unit-tests-2/#run-your-tests","title":"Run Your Tests","text":"<p>Run the test you have written. Make sure to execute the following in <code>MathSender</code>. </p> <pre><code># In: MathSender\nfprime-util check \n</code></pre> <p>As an exercise, try the following:</p> <ol> <li> <p>Change the behavior of the component so that it does something incorrect. For example, try adding one to a telemetry value before emitting it.</p> </li> <li> <p>Rerun the test and observe what happens.</p> </li> </ol>"},{"location":"writing-unit-tests-2/#add-more-command-tests","title":"Add more command tests","text":"<p>Try to follow the pattern given in the previous section to add three more tests, one each for operations <code>SUB</code>, <code>MUL</code>, and <code>DIV</code>. Most of the work should be done in the helper that we already wrote. Each new test requires just a short test function and a short test macro.</p> <p>Run the tests to make sure everything compiles and the tests pass.</p>"},{"location":"writing-unit-tests-2/#summary","title":"Summary","text":"<p>In this section you filled out your unit test implemenation stub and ran your unit test. </p> <p>Next: Writing Unit Tests Part 3: Testing the Results</p>"},{"location":"writing-unit-tests-3/","title":"Writing Unit Tests Part 3: Testing the Results","text":""},{"location":"writing-unit-tests-3/#in-this-section","title":"In this Section","text":"<p>In this section of the tutorial, you will add another test into <code>MathSender/test/ut</code> and run the new test.</p> <p>Add a result test: Add a test for exercising the scenario in which the <code>MathReceiver</code> component sends a result back to <code>MathSender</code>.</p> <p>Add the following function signature in the \"Tests\" section of <code>MathSenderTester.hpp</code>:</p> <pre><code>// In: MathSender/test/ut/MathSenderTester.hpp\n//! Test receipt of a result\nvoid testResult();\n</code></pre> <p>Add the corresponding function body in <code>MathSenderTester.cpp</code>:</p> <p><pre><code>// In: MathSenderTester.cpp\nvoid MathSenderTester ::\n    testResult()\n{\n    // Generate an expected result\n    const F32 result = 10.0;\n    // reset all telemetry and port history\n    this-&gt;clearHistory();\n    // call result port with result\n    this-&gt;invoke_to_mathResultIn(0, result);\n    // retrieve the message from the message queue and dispatch the command to the handler\n    this-&gt;component.doDispatch();\n    // verify one telemetry value was written\n    ASSERT_TLM_SIZE(1);\n    // verify the desired telemetry channel was sent once\n    ASSERT_TLM_RESULT_SIZE(1);\n    // verify the values of the telemetry channel\n    ASSERT_TLM_RESULT(0, result);\n    // verify one event was sent\n    ASSERT_EVENTS_SIZE(1);\n    // verify the expected event was sent once\n    ASSERT_EVENTS_RESULT_SIZE(1);\n    // verify the expect value of the event\n    ASSERT_EVENTS_RESULT(0, result);\n}\n</code></pre> Explanation: This code is similar to the helper function in the previous section. The main difference is that it invokes a port directly (the <code>mathResultIn</code> port) instead of sending a command.</p>"},{"location":"writing-unit-tests-3/#add-the-tests-to-mathsendertestmain-and-run","title":"Add the Tests to MathSenderTestMain and Run","text":"<p>Add the following test macro to <code>MathSenderTestMain.cpp</code>:</p> <pre><code>// In: MathSenderTestMain.cpp\nTEST(Nominal, Result) {\n    MathModule::MathSenderTester tester; \n    tester.testResult();\n}\n</code></pre> <p>Run the tests:</p> <pre><code># In: MathSender\nfprime-util check \n</code></pre> <p>Again you can try altering something in the component code to see what effect it has on the test output.</p>"},{"location":"writing-unit-tests-3/#summary","title":"Summary","text":"<p>In this section, you created another helper function used to look test the received results as seen by the <code>MathSender</code>. You ran the test that you should wrote to ensure that it worked. </p> <p>Next: Writing Unit Tests Part 4: Random testing</p>"},{"location":"writing-unit-tests-4/","title":"Writing Unit Tests Part 4: Random testing","text":""},{"location":"writing-unit-tests-4/#background","title":"Background","text":"<p>Testing using only numbers that you hard code into your tests can easily leave edge cases untouched can allow you, the programmer, to miss bugs.</p> <p>F' provides a module called STest that provides helper classes and functions for writing unit tests. As an exercise, use the interface provided by STest/STest/Pick.hpp to pick random values to use in the tests instead of using hard-coded values such as 2.0, 3.0, and 10.</p>"},{"location":"writing-unit-tests-4/#in-this-section","title":"In this Section","text":"<p>In this section of the tutorial, you will create test that uses random numbers instead of hard coded numbers.</p> <p>To incorporate random numbers into the existing tests you have written for <code>MathSender</code>, you only need to make a couple small modifications.</p> <p>First, edit <code>MathSender/test/ut/MathSenderTester.cpp</code> by adding a <code>Pick.hpp</code> to the includes:</p> <pre><code>// In: MathSenderTester.cpp\n#include \"MathSenderTester.hpp\"\n#include \"STest/Pick/Pick.hpp\"\n</code></pre> <p>Second, modify <code>MathSenderTestMain.cpp</code> to include <code>Random.hpp</code>:</p> <pre><code>// In: MathSenderTestMain.cpp\n#include \"MathSenderTester.hpp\"\n#include \"STest/Random/Random.hpp\"\n</code></pre> <p>Third, add the following line to the main function of <code>MathSenderTestMain.cpp</code>, just before the return statement:</p> <pre><code>// In: MathSenderTestMain.cpp\n// Within: int main(){\nSTest::Random::seed();\n</code></pre> <p>Fourth, modify <code>MathSender/CMakeLists.txt</code> to include STest as a build dependancy:</p> <p><pre><code># In: /MathSender/CMakeLists.txt\n# Above: register_fprime_ut()\nset(UT_MOD_DEPS STest)\n</code></pre> Fifth, recompile and rerun the tests.</p> <pre><code># In: MathSender\nfprime-util check\n</code></pre> <p>Go to MathProject/build-fprime-automatic-native-ut/Components/MathSender and inspect the file <code>seed-history</code>. This file is a log of random seed values. Each line represents the seed used in the corresponding run.</p> <p>Fixing the Random Seed: Sometimes you may want to run a test with a particular seed value, e.g., for replay debugging. To do this, put the seed value into a file <code>seed</code> in the same directory as <code>seed-history</code>. If the file seed exists, then STest will use the seed it contains instead of generating a new seed.</p> <p>Try the following:</p> <ol> <li> <p>Copy the last value S of <code>seed-history</code> into <code>seed</code>.</p> </li> <li> <p>In Components/MathSender, re-run the unit tests a few times.</p> </li> <li> <p>Inspect <code>MathProject/build-fprime-automatic-native-ut/Components/MathSender/seed-history</code>. You should see that the value S was used in the runs you just did (corresponding to the last few entries in seed-history).</p> </li> </ol>"},{"location":"writing-unit-tests-4/#summary","title":"Summary","text":"<p>In this section you incorprated random testing into your existing tests.</p> <p>Next: Writing Unit Tests 5</p>"},{"location":"writing-unit-tests-5/","title":"Writing Unit Tests Part 5: Creating the Implementation Stub","text":""},{"location":"writing-unit-tests-5/#in-this-section","title":"In this Section","text":"<p>In this section of the tutorial, you will be repeating the steps you used to create an implementation stub for <code>MathSender</code>. </p>"},{"location":"writing-unit-tests-5/#create-a-directory-for-the-unit-tests","title":"Create a Directory for the Unit Tests","text":"<p>In <code>Components/MathReceiver</code>, create a directory called test/ut </p> <pre><code># In: MathReceiver\nmkdir -p test/ut\n</code></pre> <p>Add the unit test to the build. Absolutely make sure that this is BELOW the existing stuff in the CMakeLists.txt:</p> <pre><code># In: MathReceiver/CMakeLists.txt\n# Below: register_fprime_module()\n\nset(UT_SOURCE_FILES\n  \"${CMAKE_CURRENT_LIST_DIR}/MathReceiver.fpp\"\n)\nset(UT_AUTO_HELPERS ON)\nregister_fprime_ut()\n</code></pre>"},{"location":"writing-unit-tests-5/#generate-the-unit-test-stub","title":"Generate the unit test stub","text":"<p>Generate a stub implementation of the unit tests.</p> <pre><code># In: MathReceiver\nfprime-util impl --ut\n</code></pre> <p>These commands may take a while to run.</p> <p>You haved just generate three new files <code>MathReceiverTester.cpp MathReceiverTester.hpp MathReceiverTestMain.cpp</code>. Move these files to the test/ut directory in MathReceiver using:</p> <pre><code># In: MathReceiver\nmv MathReceiverTester.* MathReceiverTestMain.cpp test/ut\n</code></pre> <p>Add <code>MathReceiverTester.cpp and MathReceiverTestMain.cpp</code> to the build. Do so by editing the CMakeLists.txt in MathReceiver: </p> <pre><code># In: MathReceiver/CMakeLists.txt \nset(UT_SOURCE_FILES\n  \"${CMAKE_CURRENT_LIST_DIR}/MathReceiver.fpp\"\n  \"${CMAKE_CURRENT_LIST_DIR}/test/ut/MathReceiverTester.cpp\"\n  \"${CMAKE_CURRENT_LIST_DIR}/test/ut/MathReceiverTestMain.cpp\"\n)\nset(UT_AUTO_HELPERS ON)\nregister_fprime_ut()\n</code></pre> <p>Note: most of this is from a few steps ago, you will only be adding two lines in this step. </p> <p>Build the unit test in MathReceiver:</p> <pre><code># In: MathReceiver\nfprime-util build --ut \n</code></pre> <p>Don't forget to add <code>--ut</code> or else you are just going to build the component again. </p>"},{"location":"writing-unit-tests-5/#preparing-for-random-testing","title":"Preparing for Random Testing","text":"<p>Complete the following steps to prepare for random testing. </p> <pre><code>// In: MathReceiverTester.cpp\n#include \"MathReceiverTester.hpp\"\n#include \"STest/Pick/Pick.hpp\"\n</code></pre> <pre><code>// In: MathReceiverTestMain.cpp\n#include \"MathReceiverTester.hpp\"\n#include \"STest/Random/Random.hpp\"\n</code></pre> <pre><code>// In: MathReceiverTestMain.cpp\n// Within: int main(){\nSTest::Random::seed();\n</code></pre> <pre><code># In: /MathReceiver/CMakeLists.txt\n# Above: register_fprime_ut()\nset(UT_MOD_DEPS STest)\n</code></pre>"},{"location":"writing-unit-tests-5/#summary","title":"Summary","text":"<p>In this section you have setup implementation stubs to begin writing unit tests for <code>MathReceiver</code>. </p> <p>Next: Writing Unit Tests 6</p>"},{"location":"writing-unit-tests-6/","title":"Writing Unit Tests Part 6: Writing Helper Functions","text":""},{"location":"writing-unit-tests-6/#in-this-section","title":"In this Section","text":"<p>In this section of the tutorial, you will write helper functions to tests various function of <code>MathReceiver</code>.</p>"},{"location":"writing-unit-tests-6/#add-a-throttlestate-enum-class","title":"Add a ThrottleState enum class","text":"<p>Add the following code to the beginning of the <code>MathReceiverTester</code> class in MathReceiverTester.hpp`:</p> <pre><code>// In: MathReceiverTester.hpp\nprivate:\n\n  // ----------------------------------------------------------------------\n  // Types\n  // ----------------------------------------------------------------------\n\n  enum class ThrottleState {\n    THROTTLED,\n    NOT_THROTTLED\n  };\n</code></pre> <p>This code defines a C++ enum class for recording whether an event is throttled.</p>"},{"location":"writing-unit-tests-6/#add-helper-functions","title":"Add helper functions","text":"<p>Add each of the functions described below to the \"Helper methods\" section of <code>MathReceiverTester.cpp</code>. For each function, you must add the corresponding function prototype to <code>MathReceiverTester.hpp</code>. After adding each function, compile the unit tests to make sure that everything still compiles. Fix any errors that occur.</p> <p>Add a <code>pickF32Value</code> function.</p> <pre><code>// In: MathReceiverTester.cpp\nF32MathReceiverTester ::\n  pickF32Value()\n{\n  const F32 m = 10e6;\n  return m * (1.0 - 2 * STest::Pick::inUnitInterval());\n}\n</code></pre> <p>Remember to add a function signature in <code>MathReceiverTester.hpp</code>. </p> <p>This function picks a random <code>F32</code> value in the range [ -10^6, 10^6 ].</p> <p>At this point, it is a good to check the build. Use the following to check the build:</p> <pre><code># In: MathReceiver\nfprime-util build --ut -j4\n</code></pre>"},{"location":"writing-unit-tests-6/#add-a-set-factor-function","title":"Add a Set Factor function","text":"<p>Copy and paste in the code below to create the <code>setFactor</code> function</p> <pre><code>// In MathReceiverTester.cpp  \nvoid MathReceiverTester ::\n  setFactor(\n      F32 factor,\n      ThrottleState throttleState\n  )\n{\n    // clear history\n    this-&gt;clearHistory();\n    // set the parameter\n    this-&gt;paramSet_FACTOR(factor, Fw::ParamValid::VALID);\n    const U32 instance = STest::Pick::any();\n    const U32 cmdSeq = STest::Pick::any();\n    this-&gt;paramSend_FACTOR(instance, cmdSeq);\n    if (throttleState == ThrottleState::NOT_THROTTLED) {\n        // verify the parameter update notification event was sent\n        ASSERT_EVENTS_SIZE(1);\n        ASSERT_EVENTS_FACTOR_UPDATED_SIZE(1);\n        ASSERT_EVENTS_FACTOR_UPDATED(0, factor);\n    }\n    else {\n        ASSERT_EVENTS_SIZE(0);\n    }\n}\n</code></pre> <p>Make sure that set factor is below where you defined <code>ThrottleSate</code> and remember to add a function signature in <code>MathReceiverTester.hpp</code>.</p>"},{"location":"writing-unit-tests-6/#explanation","title":"Explanation","text":"<p>This function does the following:</p> <ol> <li> <p>Clear the test history.</p> </li> <li> <p>Send a command to the component to set the <code>FACTOR</code> parameter to the value <code>factor</code>.</p> </li> <li> <p>If <code>throttleState</code> is <code>NOT_THROTTLED</code>, then check that the event was emitted. Otherwise check that the event was throttled (not emitted).</p> </li> </ol> <p>Build to make sure everything is working. </p>"},{"location":"writing-unit-tests-6/#create-a-compute-result-function","title":"Create a Compute Result Function","text":"<p>Add a function <code>computeResult</code> to <code>MathReceiverTester.cpp</code>.</p> <pre><code>// In: MathReceiverTester.cpp\nF32 MathReceiverTester ::\n  computeResult(\n      F32 val1,\n      MathOp op,\n      F32 val2,\n      F32 factor\n  )\n{\n    F32 result = 0;\n    switch (op.e) {\n        case MathOp::ADD:\n            result = val1 + val2;\n            break;\n        case MathOp::SUB:\n            result = val1 - val2;\n            break;\n        case MathOp::MUL:\n            result = val1 * val2;\n            break;\n        case MathOp::DIV:\n            result = val1 / val2;\n            break;\n        default:\n            FW_ASSERT(0, op.e);\n            break;\n    }\n    result *= factor;\n    return result;\n}\n</code></pre> <p>Don't forget to add a function signature in <code>MathReceiverTester.hpp</code>.</p> <p>This function carries out the math computation of the math component. By running this function and comparing, we can check the output of the component.</p> <p>Build to make sure everything is working. </p>"},{"location":"writing-unit-tests-6/#create-a-do-math-op-functions","title":"Create a Do Math Op Functions","text":"<p>Add a <code>doMathOp</code> function to <code>MathReceiverTester.cpp</code>.</p> <pre><code>// In: MathReceiverTester.cpp\nvoid MathReceiverTester ::\n  doMathOp(\n      MathOp op,\n      F32 factor\n  )\n{\n\n    // pick values\n    const F32 val1 = pickF32Value();\n    const F32 val2 = pickF32Value();\n\n    // clear history\n    this-&gt;clearHistory();\n\n    // invoke operation port with add operation\n    this-&gt;invoke_to_mathOpIn(0, val1, op, val2);\n    // invoke scheduler port to dispatch message\n    const U32 context = STest::Pick::any();\n    this-&gt;invoke_to_schedIn(0, context);\n\n    // verify the result of the operation was returned\n\n    // check that there was one port invocation\n    ASSERT_FROM_PORT_HISTORY_SIZE(1);\n    // check that the port we expected was invoked\n    ASSERT_from_mathResultOut_SIZE(1);\n    // check that the component performed the operation correctly\n    const F32 result = computeResult(val1, op, val2, factor);\n    ASSERT_from_mathResultOut(0, result);\n\n    // verify events\n\n    // check that there was one event\n    // if you're dviding by zero, there may be two events ;) \n    ASSERT_EVENTS_SIZE(1);\n    // check that it was the op event\n    ASSERT_EVENTS_OPERATION_PERFORMED_SIZE(1);\n    // check that the event has the correct argument\n    ASSERT_EVENTS_OPERATION_PERFORMED(0, op);\n\n    // verify telemetry\n\n    // check that one channel was written\n    ASSERT_TLM_SIZE(2);\n    // check that it was the op channel\n    ASSERT_TLM_OPERATION_SIZE(1);\n    // check for the correct value of the channel\n    ASSERT_TLM_OPERATION(0, op);\n\n}\n</code></pre> <p>Don't forget to add a function signature in <code>MathReceiverTester.hpp</code>.</p> <p>This function is similar to the <code>doMath</code> helper function that we wrote for the <code>MathSender</code> component. Notice that the method for invoking a port is different. Since the component is queued, we don't call <code>doDispatch</code> directly. Instead we invoke <code>schedIn</code>.</p> <p>Build before moving onto the next section.</p> <p>Next: Writing Unit Tests 7</p>"},{"location":"writing-unit-tests-7/","title":"Writing Unit Tests Part 7: Writing the Tests","text":""},{"location":"writing-unit-tests-7/#in-this-section","title":"In this Section","text":"<p>In this section of the tutorial, you will write tests that make use of the helper functions youwrote in the last section of the tutorial.</p>"},{"location":"writing-unit-tests-7/#preface","title":"Preface","text":"<p>For each of the tests described below, you must add the corresponding function prototype to <code>MathReceiverTester.hpp</code> and the corresponding test macro to <code>main.cpp</code>. If you can't remember how to do it, look back at the <code>MathSender</code> examples. After writing each test, run all the tests and make sure that they pass.</p>"},{"location":"writing-unit-tests-7/#write-an-add-test","title":"Write an ADD test","text":"<p>Add the following function to the <code>Tests</code> section of <code>MathReceiverTester.cpp</code>:</p> <pre><code>// In: MathReceiverTester.cpp\nvoid MathReceiverTester ::\n  testAdd()\n{\n    // Set the factor parameter by command\n    const F32 factor = pickF32Value();\n    this-&gt;setFactor(factor, ThrottleState::NOT_THROTTLED);\n    // Do the add operation\n    this-&gt;doMathOp(MathOp::ADD, factor);\n}\n</code></pre> <p>Don't forget to add a function signature in <code>MathReceiverTester.hpp</code>.</p> <p><code>testAdd()</code> calls the <code>setFactor</code> helper function to set the factor parameter. Then it calls the <code>doMathOp</code> function to do a math operation.</p>"},{"location":"writing-unit-tests-7/#write-a-sub-test","title":"Write a SUB test","text":"<p>Add the following function to the <code>Tests</code> section of <code>MathReceiverTester.cpp</code>:</p> <pre><code>// In: MathReceiverTester.cpp\nvoid MathReceiverTester ::\n  testSub()\n{\n    // Set the factor parameter by loading parameters\n    const F32 factor = pickF32Value();\n    this-&gt;paramSet_FACTOR(factor, Fw::ParamValid::VALID);\n    this-&gt;component.loadParameters();\n    // Do the operation\n    this-&gt;doMathOp(MathOp::SUB, factor);\n}\n</code></pre> <p><code>testSub()</code> is similar to <code>testAdd</code>, but it shows another way to set a parameter. <code>testAdd</code> shows how to set a parameter by command. You can also set a parameter by initialization, as follows:</p> <ol> <li> <p>Call the <code>paramSet</code> function as shown. This function sets the parameter value in the part of the test harness that mimics the behavior of the parameter database component.</p> </li> <li> <p>Call the <code>loadParameters</code> function as shown. In flight, the function <code>loadParameters</code> is typically called at the start of FSW to load the parameters from the database; here it loads the parameters from the test harness. There is no command to update a parameter, so <code>parameterUpdated</code> is not called, and no event is emitted.</p> </li> </ol> <p>As before, after setting the parameter you call <code>doMathOp</code> to do the operation.</p> <p>Write a MUL test: This test is the same as the ADD test, except that it uses MUL instead of add.</p> <p>Write a DIV test: This test is the same as the SUB test, except that it uses DIV instead of SUB.</p> <p>Write a throttle test: Add the following constant definition to the top of the <code>MathReceiverTester.cpp</code> file:</p> <pre><code>// In: MathReceiverTester.cpp\n#define CMD_SEQ 42\n</code></pre>"},{"location":"writing-unit-tests-7/#write-a-throttle-test","title":"Write a Throttle Test","text":"<p>Add the following function to the \"Tests\" section of <code>MathReceiverTester.cpp</code>:</p> <pre><code>// In: MathReceiverTester.cpp\nvoid MathReceiverTester ::\n  testThrottle()\n{\n\n    // send the number of commands required to throttle the event\n    // Use the autocoded value so the unit test passes if the\n    // throttle value is changed\n    const F32 factor = pickF32Value();\n    for (\n        U16 cycle = 0;\n        cycle &lt; MathReceiverComponentBase::EVENTID_FACTOR_UPDATED_THROTTLE;\n        cycle++\n    ) {\n        this-&gt;setFactor(factor, ThrottleState::NOT_THROTTLED);\n    }\n\n    // Event should now be throttled\n    this-&gt;setFactor(factor, ThrottleState::THROTTLED);\n\n    // send the command to clear the throttle\n    this-&gt;sendCmd_CLEAR_EVENT_THROTTLE(TEST_INSTANCE_ID, CMD_SEQ);\n    // invoke scheduler port to dispatch message\n    const U32 context = STest::Pick::any();\n    this-&gt;invoke_to_schedIn(0, context);\n    // verify clear event was sent\n    ASSERT_EVENTS_SIZE(1);\n    ASSERT_EVENTS_THROTTLE_CLEARED_SIZE(1);\n\n    // Throttling should be cleared\n    this-&gt;setFactor(factor, ThrottleState::NOT_THROTTLED);\n\n}\n</code></pre>"},{"location":"writing-unit-tests-7/#explanation","title":"Explanation","text":"<p>This test first loops over the throttle count, which is stored for us in the constant <code>EVENTID_FACTOR_UPDATED_THROTTLE</code> of the <code>MathReceiver</code> component base class. On each iteration, it calls <code>setFactor</code>. At the end of this loop, the <code>FACTOR_UPDATED</code> event should be throttled.</p> <p>Next the test calls <code>setFactor</code> with a second argument of <code>ThrottleState::THROTTLED</code>. This code checks that the event is throttled.</p> <p>Next the test sends the command <code>CLEAR_EVENT_THROTTLE</code>, checks for the corresponding notification event, and checks that the throttling is cleared.</p> <p>Add your tests to <code>MathReceiverTestMain.cpp</code> so that the tests run when `fprime-util check' is called.</p> <p>Here is how to include <code>testAdd</code> to <code>MathReceiverTestMain.cpp</code>. Follow this patttern to inlcude any other unit tests you wrote:</p> <pre><code>// In: MathReceiverTestMain.cpp\nTEST(Nominal, AddCommand) {\n    MathModule::MathReceiverTester tester;\n    tester.testAdd();\n}\n</code></pre> <p>See if your tests are working and trouble shoot any errors:</p> <pre><code># In: MathReceiver\nfprime-util check\n</code></pre> <p>Next: Adding Telemetry</p>"}]}